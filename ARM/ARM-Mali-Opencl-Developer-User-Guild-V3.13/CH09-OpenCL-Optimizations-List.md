# Ch09 OpenCL Optimizations List

本章列出了为Mali GPU编写OpenCL代码时要使用的几种优化。

## 9.1 General optimizations

ARM建议进行常规优化，例如处理大量数据，使用正确的数据类型以及编译内核一次。

- 为作业使用最佳处理器

  GPU被设计用于并行处理。
  
  应用处理器专为高速串行计算而设计。
  
  所有应用程序均包含执行控制功能的部分以及执行计算功能的其他部分。为了获得最佳性能，请为任务使用最佳处理器：
  - 最好使用传统语言在应用处理器上执行控制和串行功能。
  - 在Mali GPU上使用OpenCL来实现可并行化的计算功能。

- 在应用程序启动时编译一次内核
  
  确保在应用程序启动时编译一次内核。这样可以大大减少固定开销。

- 入队许多工作项
  
  要最大程度地利用所有处理器或Shader核心，您必须入队许多工作项。例如，在四个Shader核心的Mali GPU系统中，使1024个或更多工作项入队。
  
  如果可以使用更少的处理器或Shader内核来执行计算，则可以通过排队更少的工作项来节省功耗。

- 处理大量数据
  
  您必须处理相对大量的数据才能获得OpenCL的好处。这是因为启动OpenCL任务的固定开销。您开始看到收益的数据集的确切大小取决于您运行OpenCL代码的处理器。

  例如，对单个640x480图像执行简单的图像处理在GPU上不太可能更快，而对1920x1080图像进行处理则更有可能受益。**尝试对具有小图像的GPU进行基准测试只能测量驱动程序的启动时间**。
  
  不要推断这些结果，以估计处理较大数据集的性能。在有代表性数据大小的应用程序上运行基准测试。

- 在128位或16字节边界上对齐数据
  
  在128位或16字节边界上对齐数据。这样可以**提高加载和保存数据的速度**。如果可以，请在**64字节边界**上对齐数据。这样可确保数据均匀地放入Mali GPU的**高速缓存**中。

- 使用正确的数据类型
  
  检查每个变量以查看其所需的范围。
  
  使用较小的数据类型有几个优点：
  - 每个周期可以使用较小的变量执行更多的操作。
  - 您可以在一个周期内加载或存储更多内容。
  - 如果将数据存储在较小的容器中，则它更易于缓存。
  
  如果精度要求不严格，请使用short，ushort或char代替它，而不是int。
  
  例如，如果将两个相对较小的数字相加，则可能不需要整数。但是，请检查是否可能发生溢出。
  
  仅在需要其附加范围时才使用浮点值。例如，如果您需要非常小的数字或非常大的数字。

- 使用正确的数据类型
  
  您可以将图像和其他数据存储为images或buffers：
  - 如果算法可以向量化，请使用buffers。
  - 如果您的算法需要插值或自动边缘钳制，请使用images。

- 不要将缓冲区合并作为优化
  
  将多个缓冲区合并到单个缓冲区中作为优化不太可能带来性能优势。
  
  例如，如果您有两个输入缓冲区，则可以将它们合并为一个缓冲区，并使用偏移量来计算数据地址。但是，这意味着每个内核都必须执行偏移量计算。
  
  最好使用两个缓冲区，并将地址作为一对内核参数传递给内核。

- 使用异步操作
  
  如果可能，请在控制线程和OpenCL线程之间使用异步操作。 例如：
  - 不要让应用处理器等待结果。
  - 确保应用程序处理器需要OpenCL线程的结果之前，还有其他操作要处理。
  - 确保应用程序处理器在执行时不会与OpenCL内核进行交互。

- 在处理过程中避免应用程序处理器与GPU的交互
  
  首先使所有内核入队，并在可能的情况下最后调用`clFinish()`。
  
  在一个或多个`clEnqueueNDRange()`调用之后调用`clFlush()`，并在检查最终结果之前调用`clFinish()`。

- 避免提交线程中的阻塞调用
  
  避免`clFinish()`或`clWaitForEvent()`或提交线程中的任何其他阻塞调用。
  
  如果可能的话，如果要在计算过程中检查结果，请等待异步回调。
  
  如果在提交线程中使用阻塞操作，请尝试双缓冲。

## 9.2 Kernel optimizations

ARM建议进行一些内核优化，例如试验工作组的大小和形状，减少线程收敛以及使用128以上的工作组。
- 查询可用于在设备上执行内核的可能的工作组大小。
  
  例如：`clGetKernelWorkgroupInfo(kernel, dev, CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t)... );`

- 为了获得最佳性能，请使用介于4到64（含4和64）之间的工作组大小，并且使用4的倍数。
  
  如果使用了屏障，则较小的工作组大小更好。
  
  选择工作组大小时，请考虑数据的内存访问模式。
  
  找到最佳的工作组规模可能会违反直觉，因此请测试其他选项以查看最快的选项。

- 如果全局work size不能被4整除，请在边界使用填充或使用不均匀的工作组大小。
  
  要确保全局工作大小可以被4整除，请添加更多的dummy线程。
  
  或者，您可以让应用处理器计算边界。
  
  您可以使用不一致的工作组大小，但这不能保证比其他选项有更好的性能。

- 如果您不确定最佳的工作组大小，请将`local_work_size`定义为`NULL`。
  
  驱动程序选择认为最佳的工作组大小。驱动程序通常选择工作组大小为64。

  注意：性能可能不是最佳的 

- 如果要设置本地工作大小，则将`reqd_work_group_size`限定符设置为内核函数。
  
  这会在编译时为驱动程序提供信息，以供寄存器使用和调整作业大小以适合Shader核心。

- 试验工作组的大小
  
  如果可以，请尝试不同的大小以查看是否有性能优势。2的倍数大小的尺寸更有可能表现更好。
  
  如果您的内核没有工作组大小的首选项，则可以将`NULL`传递给`clEnqueueNDRangeKernel()`的本地工作大小参数。

- 如果可能，请使用128或256的工作组大小。
  
  最大工作组大小通常为256，但这并非对所有内核都可行，因此驱动程序建议使用其他大小。工作组大小64是保证可用于所有内核的最小大小。
  
  如果可能，请使用128或256的工作组。这些可以最佳利用Mali GPU硬件。如果最大工作组大小小于128，则您的内核可能太复杂。

- 试验工作组的形状
  
  工作组的形状会影响应用程序的性能。例如，一个32x4的工作组可能是最佳的大小和形状。

  尝试不同的形状和尺寸，以找到适合您应用的最佳组合。

- 检查同步要求
  
  有些内核需要工作组才能使带有屏障的工作组中的工作项同步。这些通常需要特定的工作组规模。
  
  如果不需要工作项之间的同步，则工作组大小的选择取决于设备的最有效大小。
  
  您可以传入NULL以使OpenCL能够选择有效的大小。

- 检查线程间通信
  
  使用`clGetKernelWorkGroupInfo()`来检查设备是否可以执行需要最少线程间通信的内核。如果设备无法执行内核，则该算法必须实现为multi-pass算法。这涉及排队多个内核。

- 考虑合并多个内核
  
  如果您有按顺序工作的多个内核，请考虑将它们合并为一个内核。如果合并内核，请注意它们之间的依赖性。
  
  但是，如果存在大范围的数据依赖性，请不要合并内核。
  
  例如：
  - 如果有两个内核，A和B。
  - 内核B接受内核A产生的输入。
  - 如果将内核A与内核B合并形成内核C，则只能输入内核C为常量数据，以及先前输入到内核A的数据。
  - 内核C无法使用内核$A_{n-1}$的输出，因为不能保证已执行内核$A_{n-1}$。这是因为不能保证工作项的执行顺序。
   
    通常，这意味着内核A和内核B的协调系统相同。

    :star: 注意：如果组合内核需要障碍，最好将它们分开。

- 避免拆分内核
  
  避免拆分内核。如果需要拆分内核，请将其拆分为尽可能少的内核。

  :star: 注意
  - 拆分内核有时可以使您消除障碍，因此很有用。
  - 如果内核遭受寄存器压力，则拆分内核可能很有用。

- 最小化线程发散
  
  最小化线程发散是有益的，这可以提高缓存的数据局部性。
  
  为了最大程度地减少线程发散，请避免以下情况：
  - 可变长度循环。
  - 非对称条件块。

- 确保内核同时退出
  
  在Mali GPU上，分支在计算上便宜。这意味着您可以在内核中使用循环，而不会影响性能。
  
  您的内核可以包含不同的代码段，但请尝试确保内核同时退出。
  
  一种解决方法是使用桶算法。

- 使您的内核代码尽可能简单
  
  这有助于自动向量化过程。
  
  使用循环和分支可能会使自动向量化更加困难。

- 在内核代码中使用向量运算
  
  在内核代码中使用向量运算可帮助编译器将其映射到向量指令。

- 检查内核是否较小
  
  如果内核较小，请使用单一维度的数据，并确保工作组大小为2的幂。

- 使用足够数量的并发线程
  
  使用足够数量的并发线程可**以隐藏指令的执行延迟**。
  
  Shader核心执行的并发线程数取决于内核使用的活动寄存器数。使用寄存器数越多，并发线程数越少。

  编译器根据内核的复杂性以及内核一次具有多少个活动变量来确定所使用的寄存器数。

  要减少寄存器数量：
  - 尝试减少内核中的活动变量数量。
  - 使用较大的NDRange，因此有许多工作项。
  
  对此进行试验，以找到适合您的应用程序。 您可以使用离线编译器为内核生成统计信息，以帮助完成此任务。

- 优化应用程序的内存访问模式

## 9.3 Code optimizations

ARM建议进行一些代码优化，例如使用内置函数或对数据进行实验以提高算法性能。

- 向量化您的代码

  Mali Midgard GPU使用向量进行计算。 这些使您可以对每条指令执行多项操作。
  
  向量化代码可以充分利用Mali GPU硬件，因此请确保向量化代码以实现最佳性能。
  
  Mali Midgard GPU包含128位宽的向量寄存器。
  
  :star: 注意：Midgard编译器可以自动向量化某些标量代码。

- 逐步向量化
  
  逐步向量化。例如，一次开始处理一个像素，然后处理两个，然后处理四个。

- 使用向量加载和保存
  
  要在单个操作中加载尽可能多的数据，请使用向量加载。这些使您可以一次加载128位。进行同样的操作以保存数据。
  
  例如，如果要加载`char`值，请使用内置函数`vload16()`一次加载16个字节。
  
  一次加载不要加载超过128位。 这会降低性能。

- 避免处理单个值
  
  避免编写对单个字节或其他较小值进行操作的内核。编写适用于向量的内核。

- 每次加载时执行尽可能多的操作
  
  每次加载的数据元素能执行多次计算的操作通常对于在OpenCL中进行编程非常有用：
  - 尝试重用已经加载的数据。
  - 每次加载使用尽可能多的算术指令。

- 避免与float和int进行转换
  
  相对于float和int的转换比较昂贵，因此请尽可能避免。

- 进行实验，以了解执行算法的速度。
  
  有许多变量可以确定应用程序的性能。变量之间的某些相互作用可能非常复杂，很难预测它们如何影响性能。

  实验一下您的OpenCL内核，看看它们可以运行多快： 
  - 数据类型
    
    尽可能使用最小的数据类型进行计算。

    例如，如果您的数据不超过16位，则不要使用32位类型。
  - load store类型
  
    尝试更改每个工作项处理的数据量。

  - 数据排列
  
    更改数据排列以最大程度地利用处理器缓存。

  - 最大化加载的数据
  
    始终在单个操作中加载尽可能多的数据。使用128位宽的向量加载可在每次加载时加载尽可能多的数据项。

- 使用移位而不是除法
  
  如果要除以2的幂，请使用移位而不是除法。
   
  注意
  - 这仅适用于整数。
  - 这仅适用于2的幂。
  - 除法和移位使用不同的方法对负数进行四舍五入。

- 使用向量加载并保存标量数据
  
  即使您不将数据作为向量处理，也请对数据数组使用向量加载VLOAD指令。这使您可以通过一条指令来加载多个数据元素。128位向量加载与加载单个字符所花费的时间相同。单个字符的多次加载可能会导致高速缓存抖动，这会降低性能。进行同样的操作以保存数据。

- 使用内置函数的精确版本
  
  使用内置函数的精确版本。
  
  通常，内置函数的`half_`或`native_`版本不会提供任何额外的性能。以下功能是例外： 
  - native_sin().
  - native_cos().
  - native_tan().
  - native_divide().
  - native_exp().
  - native_sqrt().
  - half_sqrt().

- 使用`_sat()`函数代替`min()`或`max()`
  
  `_sat()`函数会自动取最大值或最小值，如果这些值对于表示而言太高或太低。您不需要添加其他`min()`或`max()`代码。

- 避免编写使用许多live变量的内核
  
  避免编写使用许多live变量的内核。使用过多的live变量会影响性能并限制最大工作组大小。

- 不要在内核中计算常量
  - 对常量使用define。
  - 如果仅在运行时知道这些值，请在主机应用程序中计算它们，并将它们作为参数传递给内核。
  
    例如，高度1。

- 使用脱机编译器生成统计信息
  
  使用从DDK树构建的`mali_clcc`脱机编译器生成内核的统计信息，并检查算术指令与负载之间的比率。

  注意使用`-v`的脱机编译器的统计信息不适用于Bifrost GPU。

- 使用内置函数
 
  许多内置函数都是作为快速硬件指令实现的，请使用这些功能以提高性能。

- 小心使用缓存
  - 每个线程可用的缓存空间很小，因此必须谨慎使用。
  - 使用尽可能小的数据大小。
  - 使用数据访问模式来最大化空间局部性。
  - 使用数据访问模式来最大化时间局部性。

- 使用较大的顺序读取和写入。
  
  GPU上的通用计算会大量使用外部内存。使用较大的顺序读取和写入可显着提高内存性能。

## 9.4 Execution optimizations

ARM建议进行一些执行优化，例如**优化通信代码以减少延迟**。

ARM还建议：
- 如果从源构建，请在存储设备上**缓存二进制文件**。
- 如果知道应用程序初始化时使用的内核，请调用`clCreateKernelsInProgram()`以尽快启动最终编译。
  
  这样做可以确保将来使用内核时，它们会启动得更快，因为使用了现有的最终二进制文件。

- 如果使用回调提示处理器继续执行内核执行的数据，请确保在刷新队列之前已设置回调。
  
  如果不执行此操作，则回调可能**会在大量工作结束时发生，而不是在实际完成工作后才发生**。

## 9.5 Reducing the effect of serial computations

您可以通过减少和优化计算来减少串行组件对应用程序的影响。

- 使用内存映射而不是内存拷贝来传输数据。
- 优化通讯代码。为了减少延迟，请优化发送和接收数据的通信代码。
- 保持Message small。通过仅发送所需的数据来减少通信开销。
- 使用2的幂大小的存储块进行通信。确保用于通信的内存块大小为2的幂。这使数据更具可缓存性。
- 以较少的传输次数发送更多数据。
- 计算值，而不是从内存中读取它们。一个简单的计算可​​能比从内存中读取要快。
- 在应用程序处理器上进行串行计算。应用程序处理器针对低延迟任务进行了优化。
- 使用`clEnqueueFillBuffer()`填充缓冲区。Mali OpenCL驱动程序包含`clEnqueueFillBuffer()`的优化实现。在您的应用程序中代替手动实现缓冲区填充。
- 使用`clEnqueueFillImage()`填充图像。Mali OpenCL驱动程序包含`clEnqueueFillImage()`的优化实现。用它代替在应用程序中手动实现图像填充。

## 9.6 Mali™ Bifrost GPU specific optimizations

ARM建议对Mali Bifrost GPU进行一些特定的优化。

:star: 注意：仅当您专门针对Mali Bifrost GPU时，才使用这些优化。

- 确保在if语句和循环中，thread in quads all都采用相同的分支方向。

  在Mali Bifrost GPU中，四个相邻线程组成的组以quads排列在一起。如果shaders包含分支，例如if语句或loop，则quads中的分支可能采用不同的方式。这会降低性能，因为算术单元无法同时执行分支的两部分。尝试确保Thread in quads 采用相同的分支。
  
- 避免过多地使用寄存器
  
  每个线程都有64个32位工作寄存器。一个64位变量将两个相邻的32位寄存器用于其64位数据。
  
  如果线程需要64个以上的寄存器，则编译器可能会在内存中存储寄存器数据。这会降低性能和可用带宽。如果您的Shader已被load-store绑定，则尤其糟糕。

- 向量化8位和16位操作
  
  对于16位操作，请使用2-component向量来获得完整的性能。对于基本的算术运算，fp16版本的速度是fp32版本的两倍。
  
  对于8位类型（例如char），请使用4-component向量以获得最佳性能。

- 不要向量化32位操作
  
  Mali Bifrost GPU使用标量，因此不需要向量化32位操作。32位标量和向量算术运算具有相同的性能。

- 使用128位加载或存储操作
  
  128位加载或存储操作可以更有效地使用内部总线。

- 如果Thread in a quad中的所有线程均来自同一高速缓存行，则加载和存储操作会更快
  
  如果四线程中的所有线程均来自同一高速缓存行，则算术pipeline仅向负载存储单元发送一个请求以加载512位数据。
  
  例如，此示例很快，因为连续线程从内存加载连续的128位向量：

  ```c
  global float4 * input_array;
  float4 v = input_array[get_global_id(0)];
  ```

  第二个版本比较慢，因为具有相邻全局ID的四个线程从不同的缓存行加载数据。

  ```c
  global float4 * input_array;
  float4 v = input_array[4*get_global_id(0)];   
  ```

  :star: 注意：一个高速缓存行是512位。

- 如果可能的话，请使用32位算术代替64位，而64位算术的运行速度是32位算术的一半。
- 尝试在算术pipeline，load-store单元和texture单元的使用之间取得良好的平衡

